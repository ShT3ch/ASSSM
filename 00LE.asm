; А теперь я приведу листинг программы, которая больше похожая на работающую
model tiny     ; 1сегмент (64 КБ) на все-про-все (и на код, и на данные (переменные, массивы))
.code       ; эту строку надо написать, чтоб компилятор TASM понял, что дальше идет код, а не данные
org 100h

main:
mov ax, cs    ; ds - это указатель на сегмент данных, мы должны сказать процессору, что наши данные хранятся там же, где и наш код (потому что model tiny)
mov ds, ax    ; нельзя напрямую положить ds в cs - процессор так не умеет, поэтому мы кладем через ax
xor ax, ax     ; эквивалентно mov ax, 0   ; в ax мы будем хранить сумму элементов массива
xor bx, bx     ; обнулили для перемещения по массиву a

cstart:
cmp bx, n     ; сравниваем bx и размер массива
jge cend       ; выходим из цикла, если вышли за пределы массива
add ax, a[bx]   ; считаем сумму элементов
add bx, type a  ; сдвигаем индекс массива на размер одного элемента массива
jmp cstart

cend:      ; когда мы попали сюда - сумма уже посчитана и лежит в ax - осталось преобразовать машинное представление суммы (2 байта) в текстовое (число от 0 до 65535)
lea di, e   ; эквивалентно mov di, offset e - поместили указатель di на позицию после буфера buf
cstart2:      ; цикл (с постусловием) перевода числа
dec  di       ; di = di - 1
xor  dx, dx
mov bx, 10
div   bx           ; dx:ax / bx => dx-остаток, ax-частное
mov [di], DL    ; *di = DL
test  ax, ax     ; if (ax & ax)  или  cmp ax, 0
jnz   cstart2

; когда мы дошли до сюда - перевод завершен, ответ лежит в buf, но мы не хотим выводить ведущие пробелы, поэтому используем di как указатель на начало числа в буфере
mov  ah, 2  ; 9-ая функция 21h-ого прерывания - вывод строки из dx на экран
mov  dx, di
int 21h      ; зовем 21h-ое прерывание, которое возьмет функцию из ah и применит ее

; теперь осталось выйти из программы, чтоб процессор не налетел на наши данные ниже
mov  ax, 4C00h  ; эквивалентно mov ah, 4Ch  и mov AL, 0  -  т.е. функция 4C - это выход из программы, а 0 - это код возврата, т.е. это типа return 0 или exit 0
int 21h
; до сюда выполнение программы уже не дойдет

; а теперь перечисляем данные
a  dw   1, 7, 3, 4     ; массив, сумму которого мы считаем
n  dw   $ - a           ; размер массива в байтах (так проще)
buf  db  5 dup(" ")   ; буфер для вывода ответа на экран - 5 пробелов
e  db  13, 10, "$"    ; перевод строки и символ $ - конец вывода строки

end main   ; точкой входа в программу будет main
после end можно писать все что угодно - компилятор до сюда уже не дойдет